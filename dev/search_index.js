var documenterSearchIndex = {"docs":
[{"location":"methods/#Methods","page":"All methods","title":"Methods","text":"","category":"section"},{"location":"methods/","page":"All methods","title":"All methods","text":"Here are listed all the available methods of MegaQuiverTools","category":"page"},{"location":"methods/","page":"All methods","title":"All methods","text":"Modules = [MegaQuiverTools]","category":"page"},{"location":"methods/#MegaQuiverTools.Quiver","page":"All methods","title":"MegaQuiverTools.Quiver","text":"A quiver is represented by its adjacency n times n matrix adjacency = (a_ij), where n is the number of vertices and a_ij is the number of arrows i to j.\n\nAttributes:\n\nadjacency is the adjacency matrix of the quiver\nname is the name of the quiver, defaults to \"\".\n\n\n\n\n\n","category":"type"},{"location":"methods/#MegaQuiverTools.Eulerform-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"MegaQuiverTools.Eulerform","text":"Computes the Euler form of the quiver for vectors x and y.\n\nThe Euler form is defined as the bilinear form\n\nlangle xyrangle = x^T * E * y\n\nwhere E is the Euler matrix of the quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.Telemanbound_onstratum","page":"All methods","title":"MegaQuiverTools.Telemanbound_onstratum","text":"Computes the weight on det(N_SR_Z) of the 1-PS lambda corresponding to the given HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.allHNtypes","page":"All methods","title":"MegaQuiverTools.allHNtypes","text":"Returns a list of all the Harder Narasimhan types of representations of Q with dimension vector d, with respect to the slope function theta/slope_denominator.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.allTelemanbounds","page":"All methods","title":"MegaQuiverTools.allTelemanbounds","text":"Computes the weight on det(N_SR_Z) of the 1-PS corresponding to each HN type for the given Q, d, theta and denominator.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.all_generic_subdimension_vectors-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"MegaQuiverTools.all_generic_subdimension_vectors","text":"Returns the list of all generic subdimension vectors of d.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.all_weights_endomorphisms_universal_bundle","page":"All methods","title":"MegaQuiverTools.all_weights_endomorphisms_universal_bundle","text":"Computes the weights of the endomorphisms of the universal bundles U_i otimes U_j on all the non-dense Harder-Narasimhan strata for each 1-PS relative to the HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.all_weights_irreducible_component_canonical","page":"All methods","title":"MegaQuiverTools.all_weights_irreducible_component_canonical","text":"Computes the weights of the irreducible component of omega_R_Z on all the non-dense Harder-Narasimhan strata for each 1-PS relative to the HN type. More explicitly, if omega_X = O(rH), this returns the weights of the pullback of O(H) on each stratum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.all_weights_universal_bundle","page":"All methods","title":"MegaQuiverTools.all_weights_universal_bundle","text":"Computes the weights of the universal bundle U_i(a) for the linearization a on all the non-dense Harder-Narasimhan strata for each 1-PS corresponding to each HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.canonical_stability-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"MegaQuiverTools.canonical_stability","text":"The canonical stability parameter for the couple (Qd) is given by d-  -  - d\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.codimensionHNstratum-Tuple{Quiver, Vector{Vector{Int64}}}","page":"All methods","title":"MegaQuiverTools.codimensionHNstratum","text":"Returns the codimension of the given HN stratum.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.euler_matrix-Tuple{Quiver}","page":"All methods","title":"MegaQuiverTools.euler_matrix","text":"Returns the Euler matrix of the quiver.\n\nThe Euler matrix of a quiver Q is defined as \n\nE = I - A\n\nwhere A is the adjacency matrix of Q and I is the identity matrix of the same size as A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.hassemistables","page":"All methods","title":"MegaQuiverTools.hassemistables","text":"Checks if there is a theta-semistable representation of dimension vector d.\n\nExamples:\n\njulia> A2 = mKroneckerquiver(1)\njulia> theta = [1,-1]\njulia> d = [1,1]\njulia> hassemistables(A2, d, theta)\ntrue\n\njulia> d = [2,2]\njulia> hassemistables(A2, d, theta)\ntrue\n\njulia> d = [1,2]\njulia> hassemistables(A2, d, theta)\nfalse\n\njulia> d = [0,0]\njulia> hassemistables(A2, d, theta)\ntrue\n\n# The 3-Kronecker quiver:\njulia> K3 = mKroneckerquiver(3)\njulia> theta = [3,-2]\njulia> d = [2,3]\njulia> hassemistables(K3, d, theta)\ntrue\n\njulia> d = [1,4]\njulia> hassemistables(K3, d, theta)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.hasstables-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"MegaQuiverTools.hasstables","text":"Checks if Q has a theta-stable representation of dimension vector d.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.indegree-Tuple{Quiver, Int64}","page":"All methods","title":"MegaQuiverTools.indegree","text":"Returns the number of incoming arrows to the vertex j.\n\nExamples:\n\njulia> Q = mKroneckerquiver(4)\njulia> indegree(Q, 1)\n0\njulia> indegree(Q, 2)\n4\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.isSchurroot-Tuple{Quiver, Vector{Int64}}","page":"All methods","title":"MegaQuiverTools.isSchurroot","text":"Checks if d is a Schur root for Q. By a lemma of Schofield (See Lemma 4.2 of https://arxiv.org/pdf/0802.2147.pdf), this is equivalent to the existence of a stable representation of dimension vector d.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.is_generic_subdimension_vector-Tuple{Quiver, Vector{Int64}, Vector{Int64}}","page":"All methods","title":"MegaQuiverTools.is_generic_subdimension_vector","text":"Checks if e is a generic subdimension vector of d.\n\nA dimension vector e is called a generic subdimension vector of d if a generic representation of dimension vector d possesses a subrepresentation of dimension vector e.\n\nBy a result of Schofield (see Thm. 5.3 of https://arxiv.org/pdf/0802.2147.pdf) e is a generic subdimension vector of d if and only if ed-e geq 0 for all generic subdimension vectors e' of e.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.isacyclic-Tuple{Quiver}","page":"All methods","title":"MegaQuiverTools.isacyclic","text":"Checks wether the quiver is acyclic, i.e. has no oriented cycles.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.isamplystable","page":"All methods","title":"MegaQuiverTools.isamplystable","text":"Checks wether the dimension vector d is amply stable with respect to the slope function theta/denominator.\n\nThis means that the codimension of the unstable locus in the parameter space is at least 2.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.isconnected-Tuple{Quiver}","page":"All methods","title":"MegaQuiverTools.isconnected","text":"Checks wether the underlying graph of the quiver is connected.\n\nExamples:\n\njulia> Q = Quiver([0 1 0; 0 0 1; 1 0 0])\njulia> isconnected(Q)\ntrue\n\njulia> Q = Quiver([0 1 0; 1 0 0; 0 0 2])\nfalse\n\n# The 4-Kronecker quiver:\njulia> Q = mKroneckerquiver(4)\njulia> isconnected(Q)\ntrue\n\n# The 4-loop quiver:\njulia> Q = LoopQuiver(4)\njulia> isconnected(Q)\ntrue\n\n# The 4-subspace quiver:\njulia> Q = SubspaceQuiver(4)\njulia> isconnected(Q)\ntrue\n\n# The A10 quiver:\njulia> A10 = Quiver(   [0 1 0 0 0 0 0 0 0 0;\n                        0 0 1 0 0 0 0 0 0 0;\n                        0 0 0 1 0 0 0 0 0 0;\n                        0 0 0 0 1 0 0 0 0 0;\n                        0 0 0 0 0 1 0 0 0 0;\n                        0 0 0 0 0 0 1 0 0 0;\n                        0 0 0 0 0 0 0 1 0 0;\n                        0 0 0 0 0 0 0 0 1 0;\n                        0 0 0 0 0 0 0 0 0 1;\n                        0 0 0 0 0 0 0 0 0 0] )\njulia> isconnected(A10)\ntrue\n\n# The A10 quiver without one arrow:\njulia> A10 = Quiver(   [0 1 0 0 0 0 0 0 0 0;\n                        0 0 1 0 0 0 0 0 0 0;\n                        0 0 0 1 0 0 0 0 0 0;\n                        0 0 0 0 1 0 0 0 0 0;\n                        0 0 0 0 0 1 0 0 0 0;\n                        0 0 0 0 0 0 0 0 0 0;\n                        0 0 0 0 0 0 0 1 0 0;\n                        0 0 0 0 0 0 0 0 1 0;\n                        0 0 0 0 0 0 0 0 0 1;\n                        0 0 0 0 0 0 0 0 0 0] )\njulia> isconnected(A10)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.iscoprime-Tuple{Vector{Int64}, Vector{Int64}}","page":"All methods","title":"MegaQuiverTools.iscoprime","text":"Checks wether the given dimension vector d is theta-coprime for the stability parameter theta.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.iscoprime-Tuple{Vector{Int64}}","page":"All methods","title":"MegaQuiverTools.iscoprime","text":"Checks if the gcd of all the entries of d is 1.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.issink-Tuple{Quiver, Int64}","page":"All methods","title":"MegaQuiverTools.issink","text":"Checks if the vertex j is a sink, i.e., a vertex with no outgoing arrows.\n\nExamples:\n\njulia> Q = mKroneckerquiver(4)\njulia> issink(Q, 1)\nfalse\njulia> issink(Q, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.issource-Tuple{Quiver, Int64}","page":"All methods","title":"MegaQuiverTools.issource","text":"Checks if the vertex i is a source, i.e., a vertex with no incoming arrows.\n\nExamples:\n\njulia> Q = mKroneckerquiver(4)\njulia> issource(Q, 1)\ntrue\njulia> issource(Q, 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.narrows-Tuple{Quiver}","page":"All methods","title":"MegaQuiverTools.narrows","text":"Returns the number of arrows of the quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.nvertices-Tuple{Quiver}","page":"All methods","title":"MegaQuiverTools.nvertices","text":"Returns the number of vertices of the quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.outdegree-Tuple{Quiver, Int64}","page":"All methods","title":"MegaQuiverTools.outdegree","text":"Returns the number of outgoing arrows from the vertex i.\n\nExamples:\n\njulia> Q = mKroneckerquiver(4)\njulia> outdegree(Q, 1)\n4\njulia> outdegree(Q, 2)\n0\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.underlying_graph-Tuple{Quiver}","page":"All methods","title":"MegaQuiverTools.underlying_graph","text":"Returns the (necessarily symmetric) adjacency matrix of the underlying graph of the quiver.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MegaQuiverTools.weight_irreducible_component_canonical_on_stratum","page":"All methods","title":"MegaQuiverTools.weight_irreducible_component_canonical_on_stratum","text":"Computes the weight of the irreducible component of omega_R_Z on a Harder-Narasimhan stratum for the 1-PS corresponding to each HN type. More explicitly, if omega_X = O(rH), this returns the weight of the pullback of O(H) on the given stratum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.weights_endomorphism_universal_bundle_on_stratum","page":"All methods","title":"MegaQuiverTools.weights_endomorphism_universal_bundle_on_stratum","text":"Computes the weights of the endomorphism of the universal bundle U_i otimes U_j on the given Harder-Narasimhan stratum for the 1-PS relative to the HN type.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MegaQuiverTools.weights_universal_bundle_onstratum","page":"All methods","title":"MegaQuiverTools.weights_universal_bundle_onstratum","text":"Returns the weights of a universal bundle U_i(a) for the linearization a for the 1-PS corresponding to the given HN type.\n\n\n\n\n\n","category":"function"},{"location":"#MegaQuiverTools","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"","category":"section"},{"location":"#Contents","page":"MegaQuiverTools","title":"Contents","text":"","category":"section"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"","category":"page"},{"location":"#Introduction","page":"MegaQuiverTools","title":"Introduction","text":"","category":"section"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"MegaQuiverTools is a showcase version of QuiverTools, a software suite in development for treatment of quiver representations, their roots, their moduli spaces and computations of several invariants of these.","category":"page"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"QuiverTools will offer many functionalities for the treatment of quiver moduli, however this showcase version is only meant to demonstrate some of them, with one example in mind.","category":"page"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"QuiverTools will be available as a Julia package and as a Sage library.","category":"page"},{"location":"#Installation","page":"MegaQuiverTools","title":"Installation","text":"","category":"section"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"At the moment the package is not registered, so you can install it by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"pkg>add https://github.com/Catullo99/MegaQuiverTools.git","category":"page"},{"location":"#Acknowledgements","page":"MegaQuiverTools","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"QuiverTools is being developed by P. Belmans, H. Franzen and G. Petrella.","category":"page"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"The Julia version is developed and maintained by G. Petrella.","category":"page"},{"location":"","page":"MegaQuiverTools","title":"MegaQuiverTools","text":"G. Petrella was supported by the Luxembourg National Research Fund (FNR–17953441).","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At the moment the package is not registered, so you can install it by running the following command in the Julia REPL:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pkg> add https://github.com/Catullo99/MegaQuiverTools.git","category":"page"},{"location":"tutorial/#Examples","page":"Tutorial","title":"Examples","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To start using MegaQuiverTools in the REPL, one first must import it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using MegaQuiverTools","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Quivers can be built by passing the adjacency matrix to the Quiver() constructor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Quiver([0 3; 0 0])\nQuiver with adjacency matrix [0 3; 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The constructor accepts an optional string for naming the quiver:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> MyQ = Quiver([0 3; 0 0], \"My personal quiver\")\nMy personal quiver, with adjacency matrix [0 3; 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"MegaQuiverTools has several constructors in place for many common examples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> mKroneckerquiver(4)\n4-Kronecker quiver, with adjacency matrix [0 4; 0 0]\n\njulia> loopquiver(5)\n5-loop quiver, with adjacency matrix [5;;]\n\njulia> subspacequiver(3)\n3-subspace quiver, with adjacency matrix [0 0 0 1; 0 0 0 1; 0 0 0 1; 0 0 0 0]\n\njulia> threevertexquiver(1,6,7)\nAn acyclic 3-vertex quiver, with adjacency matrix [0 1 6; 0 0 7; 0 0 0]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Dimension vectors and stability parameters are represented by Vector{Int} objects:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKroneckerquiver(3); d = [2,3];\n\njulia> θ = canonical_stability(Q, d)\n2-element Vector{Int64}:\n  9\n -6\n\njulia> iscoprime(d, θ)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, iscoprime() checks if d is θ-coprime, i.e., if none of the proper subdimension vectors 0 neq d nleq d satisfies theta cdot d = 0.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The bilinear Euler form relative to a quiver Q of any two vectors in mathbbZQ can be computed:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKroneckerquiver(3); d = [2,2]; e = [3,4];\n\njulia> Eulerform(Q, d, e)\n-10\n\njulia> Eulerform(Q, e, d)\n-4","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can check if semistable, respectively stable representations exist for a given dimension vector and stability parameter:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKroneckerquiver(3); d = [2,3]; θ = [3,-2];\n\njulia> hassemistables(Q, d, θ)\ntrue\n\njulia> hasstables(Q, d, θ)\ntrue\n\njulia> K2 = mKroneckerquiver(2);\n\njulia> hasstables(K2, [2,2], [1,-1])\nfalse\n\njulia> hassemistables(K2, [2,2], [1,-1])\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also determine whether stable representations exist at all for a given dimension vector by checking if it is a Schur root:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKroneckerquiver(3); d = [2,2];\n\njulia> MegaQuiverTools.isSchurroot(Q,d)\ntrue\n\njulia> K2 = mKroneckerquiver(2);\n\njulia> MegaQuiverTools.isSchurroot(K2,d)\nfalse","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To investigate the Harder-Narasimhan stratification of the parameter space mathrmR(Qmathbfd), the module provides a recursive closed formula.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKroneckerquiver(3); d = [2,3]; θ = [3,-2];\n\njulia> allHNtypes(Q, d, θ)\n8-element Vector{Vector{Vector{Int64}}}:\n [[2, 3]]\n [[1, 1], [1, 2]]\n [[2, 2], [0, 1]]\n [[2, 1], [0, 2]]\n [[1, 0], [1, 3]]\n [[1, 0], [1, 2], [0, 1]]\n [[1, 0], [1, 1], [0, 2]]\n [[2, 0], [0, 3]]\n\njulia> isamplystable(Q, d, θ)\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method isampystable() determines whether the codimension of the θ-semistable locus, mathrmR^theta-sst(Qmathbfd)subsetmathrmR(Qmathbfd), is at least 2.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method allHNtypes() provides a list of all the Harder-Narasimhan types that appear in the problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method allTelemanbounds() computes the bounds to apply Teleman quantization on the non-dense strata. The output is a dictionary whose keys are the HN types and whose values are the weights themselves.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKroneckerquiver(3); d = [2,3]; theta = [3,-2];\n\njulia> allTelemanbounds(Q, d, theta)\nDict{Vector{Vector{Int64}}, Int64} with 7 entries:\n  [[2, 2], [0, 1]]         => 20\n  [[2, 1], [0, 2]]         => 100\n  [[1, 0], [1, 2], [0, 1]] => 100\n  [[1, 0], [1, 3]]         => 120\n  [[1, 0], [1, 1], [0, 2]] => 90\n  [[1, 1], [1, 2]]         => 15\n  [[2, 0], [0, 3]]         => 90","category":"page"},{"location":"tutorial/#Use-cases","page":"Tutorial","title":"Use cases","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following are examples of use cases for MegaQuiverTools","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Verify Teleman inequalities","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the following example, for each ij and on each Harder-Narasimhan stratum, we compute the weight of mathcalU_i^vee otimes mathcalU_j relative to the 1-PS corresponding to the HN stratum. These are then compared to the Teleman bounds.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> Q = mKroneckerquiver(3); d = [2,3]; theta = [3,-2];\n\njulia> hn = allTelemanbounds(Q,d,theta)\nDict{Vector{Vector{Int64}}, Int64} with 7 entries:\n  [[2, 2], [0, 1]]         => 20\n  [[2, 1], [0, 2]]         => 100\n  [[1, 0], [1, 2], [0, 1]] => 100\n  [[1, 0], [1, 3]]         => 120\n  [[1, 0], [1, 1], [0, 2]] => 90\n  [[1, 1], [1, 2]]         => 15\n  [[2, 0], [0, 3]]         => 90\n\njulia> endom = all_weights_endomorphisms_universal_bundle(Q,d,theta)\nDict{Vector{Vector{Int64}}, Vector{Int64}} with 7 entries:\n  [[2, 2], [0, 1]]         => [0, 5, -5, 0]\n  [[2, 1], [0, 2]]         => [0, 10, -10, 0]\n  [[1, 0], [1, 2], [0, 1]] => [0, 10, 15, -10, 0, 5, -15, -5, 0]\n  [[1, 0], [1, 3]]         => [0, 15, -15, 0]\n  [[1, 0], [1, 1], [0, 2]] => [0, 5, 10, -5, 0, 5, -10, -5, 0]\n  [[1, 1], [1, 2]]         => [0, 5, -5, 0]\n  [[2, 0], [0, 3]]         => [0, 5, -5, 0]\n\njulia> all(maximum(endom[key]) < hn[key] for key in keys(hn))\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The fact that all of these inequalities are satisfied allows to conclude that the higher cohomology of mathcalU_i^vee otimes mathcalU_j vanishes.","category":"page"}]
}
